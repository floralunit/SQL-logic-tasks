--Задача на логику, нетривиальное мышление, умение управлять сортировкой.
--Дано:
--declare @dt datetime = '2024-01-06'
--select *
--from
--(values
--(cast
--('2024-01-01' as datetime))
--,('2024-01-02')
--,('2024-01-03')
--,('2024-01-04')
--,('2024-01-05')
--,('2024-01-06')
--,('2024-01-07')
--,('2024-01-08')
--,('2024-01-09')
--,('2024-01-10')
--) as t (dt)
--order by dt

--Результат:
--dt
--2024-01-01 00:00:00.000
--2024-01-02 00:00:00.000
--2024-01-03 00:00:00.000
--2024-01-04 00:00:00.000
--2024-01-05 00:00:00.000
--2024-01-06 00:00:00.000
--2024-01-07 00:00:00.000
--2024-01-08 00:00:00.000
--2024-01-09 00:00:00.000
--2024-01-10 00:00:00.000
--Требуется
--изменить только выражение в order by
--не используя при этом select и не дублируя название поля dt и/или переменную @dt, чтобы начиная с даты
--@dt и ранее (dt<=@dt) сортировка была в обратном порядке, а после даты @dt (dt>@dt) сортировка была по
--возрастанию. Приоритет сортировки начиная c @dt на убывание, как в представленном ниже результате.
--Необходимо, чтобы запрос умел работать в диапазоне дат от 0001-01-01 до 9999-12-31

--Результат должен выглядеть так:
--dt
--2024-01-06 00:00:00.000
--2024-01-05 00:00:00.000
--2024-01-04 00:00:00.000
--2024-01-03 00:00:00.000
--2024-01-02 00:00:00.000
--2024-01-01 00:00:00.000
--2024-01-07 00:00:00.000
--2024-01-08 00:00:00.000
--2024-01-09 00:00:00.000
--2024-01-10 00:00:00.000
--Если это сложно, то разрешается дублировать @dt и dt в выражении order by, что сильно упрощает задачу.
--Если и это будет совсем трудоёмко, то можете представить своё решение на основе этого запроса, без
--использования CTE, чтобы ваш запрос можно было бы встроить в представление, то есть это будет один
--запрос, как в условии.
--Чтобы вы понимали, что задача простая:
--без дубликатов @dt и dt в выражении order by у меня получилось выражение длиной - 93 символа,
--с дубликатами @dt и dt (то есть в выражении @dt и dt используются не один раз) – 54 символа.

declare @dt datetime = '2024-01-06'
select *
from
(values
(cast
('2024-01-01' as datetime))
,('2024-01-02')
,('2024-01-03')
,('2024-01-04')
,('2024-01-05')
,('2024-01-06')
,('2024-01-07')
,('2024-01-08')
,('2024-01-09')
,('2024-01-10')
) as t (dt)
--1 вариант с дублированием dt и @dt
--order by case when dt <= @dt then dt end desc, case when dt > @dt then dt end

--2 вариант без дублирования @dt
order by case
when dt > @dt then abs(DATEDIFF(day, dt, '0001-01-01')) + DateDiff(day,
'0001-01-01', '9999-12-31')
else DATEDIFF(day, dt, '9999-12-31')
end